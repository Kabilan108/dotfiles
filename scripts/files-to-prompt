#!/bin/bash

# Exit on error
set -e

# Function to escape any special XML characters in the file content
escape_xml() {
    # Replace & with &amp;, < with &lt;, > with &gt;
    sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g'
}

# Initialize array for ignore patterns
declare -a ignore_patterns

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --ignore|-i)
            if [[ -n "$2" ]]; then
                ignore_patterns+=("$2")
                shift 2
            else
                echo "Error: --ignore/-i requires a pattern" >&2
                exit 1
            fi
            ;;
        *)
            target_dir="$1"
            shift
            ;;
    esac
done

# Set default target directory if not provided
target_dir="${target_dir:-.}"

# Convert to absolute path
target_dir=$(realpath "$target_dir")

# Check if directory exists
if [ ! -d "$target_dir" ]; then
    echo "Error: Directory '$target_dir' does not exist" >&2
    exit 1
fi

# Change to the target directory
cd "$target_dir"

# Build find command with ignore patterns
find_cmd="find . -type f ! -path \"./.git/*\" ! -name \".DS_Store\""
for pattern in "${ignore_patterns[@]}"; do
    find_cmd+=" ! -path \"$pattern\""
done
find_cmd+=" -print0"

# Execute the find command
eval "$find_cmd" | while IFS= read -r -d '' file; do
    # Remove leading ./
    file="${file#./}"

    if file -b --mime-encoding "$file" | grep -q binary; then
        continue
    elif echo "$file" | grep -q \\bprompt\$; then
        continue
    fi

    # Get absolute path
    absolute_path="$target_dir/$file"

    # Output the opening tag with the path
    echo "<file path='$absolute_path'>"

    # Output the file content with XML escaping
    cat "$absolute_path" | escape_xml

    # Output the closing tag
    echo "</file>"

    # Add a newline for readability
    echo ""
done
